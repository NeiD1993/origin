/*  Created: 24.11.2016
    Author: Dmitry Vasiliev
    Text editor: Sublime Text
    GitHub: swimmwatch  */

/**
 * Module provide functional for work with time.
 * @module util-time
 * @license MIT
 * @author Dmitry Vasiliev <mushckin.igor2011@yandex.ru>
 */

/**
 * @classdesc Wrapper for setTimeout.
 */
 class Timer {
  private callback: (timestamp?: number) => void = null;
  private beginnigTime: number = null;
  private pastTime: number = null;
  private stopPoint: number = null;
  private duration: number = null;
  private totalTime: number = null;
  private timer: number = null;
  private running: boolean = false;

  /**
   * Create timer.
   */
  constructor() { /* */ }

  /**
   * Return timerstamp of timer.
   * @memberof Timer
   * @private
   * @readonly
   */
  private get timestamp(): number {
    return +(new Date()) - this.beginnigTime;
  }

  /**
   * Start the timer
   * @param duration Duration of timer
   * @param callback Callback function
   * @memberof Timer
   * @public
   */
  public start(duration: number, callback: (timestamp?: number) => void): void {
    // If timer is running then restart it.
    if (this.running) {
      this.reset();
    }
    // Check on available necessary params.
    if (typeof callback !== 'function') {
      throw new TypeError('Callback function is not function.');
    }
    if (typeof duration !== 'number') {
      throw new TypeError('Duration must be number.');
    }
    // Set properties to timer.
    this.callback = callback;
    this.duration = duration > 0 ? // If duration more then zero then...
                    duration : // return this value,
                    -duration; // else return inversion of value.
    this.totalTime = this.duration;
    this.pastTime = 0;
    this._updateTimer();
    this.running = true;
    this.stopPoint = this.beginnigTime = +(new Date());
  }

  /**
   * Reset the timer
   * @memberof Timer
   * @public
   */
  public reset(): void {
    clearTimeout(this.timer);
    this.running = false;
    this.callback =
    this.duration =
    this.pastTime =
    this.beginnigTime =
    this.stopPoint =
    this.totalTime = null;
  }

  /**
   * Pause the timer
   * @param delay Delay on pause
   * @memberof Timer
   * @public
   */
  public pause(delay?: number): void {
    // Validation of parameter.
    if (typeof delay !== 'undefined' && typeof delay !== 'number') {
      throw new TypeError('Delay must be number.');
    }
    if (this.running) {
      clearTimeout(this.timer);
      this._updatePastTime();
      this.duration = this.totalTime - this.pastTime;
      this.running = false;
      if (typeof delay !== 'undefined') {
        setTimeout(this.continue.bind(this), delay);
      }
    }
  }

  /**
   * Add to duration of timer.
   * @param amount Amount of milliseconds
   * @memberof Timer
   * @public
   */
  public add(amount: number): void {
    // Validation of parameter.
    if (typeof amount !== 'number') {
      throw new TypeError('Amount must be number.');
    }
    if (this.running) {
      // Pause the timer while eval new duration.
      clearTimeout(this.timer);
      this.running = false;
      // Calculate new duration.
      this.totalTime += amount;
      this._updatePastTime();
      this.duration = this.totalTime - this.pastTime;
      // Continue timer with new duration.
      this.continue();
    }
  }

  /**
   * Reduce to remaining duration of timer.
   * @param amount Amount of milliseconds
   * @memberof Timer
   * @public
   */
  public reduce(amount: number): void {
    // Validation of parameter.
    if (typeof amount !== 'number') {
      throw new TypeError('Amount must be number.');
    }
    if (this.running) {
      // Pause timer while calculating new duration.
      clearTimeout(this.timer);
      this.running = false;
      // Calculate new duration.
      const difference = this.totalTime - amount;
      this.totalTime = difference > 0 ? difference : this.totalTime;
      this._updatePastTime();
      this.duration = this.totalTime - this.pastTime;
      // Continue timer with new duration
      this.continue();
    }
  }

  /**
   * Continue the timer
   * @memberof Timer
   * @public
   */
  public continue(): void {
    // If timer don't playing and existing callback then continue the timer.
    if (!this.running && this.callback) {
      this.stopPoint = +(new Date());
      // Update timer.
      this._updateTimer();
      this.running = true;
    }
  }

  /**
   * Update past time.
   * @memberof Timer
   * @private
   */
  private _updatePastTime(): void {
    this.pastTime += +(new Date()) - (this.stopPoint ? this.stopPoint : this.timestamp);
    this.stopPoint = +(new Date());
  }

  /**
   * Update timer
   * @member Timer
   * @private
   */
  private _updateTimer(): void {
    this.timer = setTimeout(() => {
      this.callback(this.timestamp);
      this.reset();
    }, this.duration);
  }

}

/**
 * @classdesc Wrapper for setInterval.
 */
 class Interval {
  private callback: (iter?: number) => void = null;
  private interval: number = null;
  private timer: any = null;
  private count: number = null;
  private currCount: number = null;
  private running: boolean = false;

  /**
   * Create interval.
   */
  constructor() { /*  */ }

  /**
   * Start the interval
   * @param interval Interval.
   * @param callback Callback.
   * @param args Arguments that will be pass in callback.
   * @memberof Interval
   * @public
   */
  public start(interval: number, callback: (iter?: number) => void, count?: number): void {
    if (this.running) {
      this.reset();
    }

    // Validation necessary params.
    if (typeof callback !== 'function') {
      throw new TypeError('Callback function must be function.');
    }
    if (typeof interval !== 'number') {
      throw new TypeError('Interval must be number.');
    }
    if (typeof count !== 'undefined' && typeof count !== 'number') {
      throw new TypeError('Count must be number.');
    }

    this.interval = interval > 0 ? // If interval isn't negative then...
                    interval : // return it,
                    -interval; // else return inversion of value.
    this.callback = callback;

    this.currCount = 0;
    this.count = count === 0 ? 1 : count;

    this._updateInterval();

    this.running = true;
  }

  /**
   * Reset the interval
   * @memberof Interval
   * @public
   */
  public reset(): void {
    clearInterval(this.timer);
    this.running = false;
    this.interval =
    this.callback =
    this.count =
    this.currCount = null;
  }

  /**
   * Pause the interval.
   * @param delay Delay.
   * @memberof Interval
   * @public
   */
  public pause(delay?: number): void {
    if (typeof delay !== 'undefined' && typeof delay !== 'number') {
      throw new TypeError('Delay must be number');
    }
    clearInterval(this.timer);
    this.running = false;
    if (typeof delay !== 'undefined') {
      setTimeout(this.continue.bind(this), delay);
    }
  }

  /**
   * Continue the interval.
   * @memberof Interval
   * @public
   */
  public continue(): void {
    this._updateInterval();
    this.running = true;
  }

  /**
   * Add iterations to the interval.
   * @param amount Amount of iterations.
   * @memberof Interval
   * @public
   */
  public add(amount: number): void {
    if (typeof amount !== 'number') {
      throw new TypeError('Amount must be number.');
    }
    this.count += amount;
  }

  /**
   * Reduce iterations to the interval.
   * @param amount Amount of iterations.
   * @memberof Interval
   * @public
   */
  public reduce(amount: number): void {
    if (typeof amount !== 'number') {
      throw new TypeError('Amount must be number.');
    }
    this.count -= amount;
  }

  /**
   * Update interval.
   * @memberof Interval
   * @private
   */
  private _updateInterval(): void {
    if (this.count) {
      this.timer = setInterval(() => {
        this.currCount++;
        this.callback(this.currCount);
        if (this.currCount === this.count) {
          this.reset();
        }
      }, this.interval);
    } else {
      this.timer = setInterval(this.callback, this.interval);
    }
  }

}
